<?xml version="1.0"?>
<!--
  Created by Yo on 2015/11/5.
-->
<s:TitleWindow xmlns:fx="http://ns.adobe.com/mxml/2009" xmlns:s="library://ns.adobe.com/flex/spark" title="房间拆分-{mouseLocationX}-{mouseLocationY}"
               xmlns:mm="random.components.*" xmlns:demo="random.demo.*"
               width="{gcGroup.width + 100}" height="{gcGroup.height + 100}"
               creationComplete="creationCompleteHandler(event)">

<fx:Script><![CDATA[
    import mx.collections.ArrayList;
    import mx.controls.Alert;
    import mx.events.FlexEvent;
    import mx.graphics.GradientStroke;
    import mx.graphics.SolidColor;
    import mx.graphics.SolidColorStroke;

    import random.utils.CalculationUtils;
    import random.utils.Constants;

    import random.valueObject.CoordinateVo;

    import spark.primitives.Ellipse;
    import spark.primitives.Graphic;
    import spark.primitives.Line;
    import spark.primitives.Path;
    import spark.primitives.Rect;

    // 所选房间的有效坐标
    private var _roomValidCoordinates:ArrayList;
    // source data 有效坐标和现实坐标
    private var _roomReductionCoordinates:ArrayList;
    // 窗口内使用的坐标 -minX -minY
    private var internalCoordinates:Array;
    //  连线属猪 Path 列表
    private var splitedPolygons:Array;
    // Rect 列表
    private var rectList:ArrayList = new ArrayList();
    // 当前移动的对角线
    private var currentRect:CustomRect = null;

    // 边框偏移
    [Bindable]
    private var offsetX:int = 33;
    [Bindable]
    private var offsetY:int = 33;

    // 舞台坐标偏移量
    private var pointOffsetXInStage:Number = -1;
    private var pointOffsetYInStage:Number = -1;

    //  X, Y 坐标的最小值
    private var minX:Number = 0;
    private var minY:Number = 0;

    [Bindable]
    private var mouseLocationX:Number = 0;
    [Bindable]
    private var mouseLocationY:Number = 0;


    public function set roomReductionCoordinates(value:ArrayList):void {
        _roomReductionCoordinates = value;
    }

    public function set roomValidCoordinates(value:ArrayList):void {
        _roomValidCoordinates = value;
    }

    /**
     *  创建完成绘制点和边界
     * @param event
     */
    private function creationCompleteHandler(event:FlexEvent):void {
//        Alert.show(JSON.stringify(_roomReductionCoordinates));
        this.findLeftTopCoordinate(function (minX:int, minY:int):void {
            internalCoordinates = new Array();
            _roomReductionCoordinates.toArray().forEach(function (item:Object, index:int, arr:Array):void {
                internalCoordinates.push(new CoordinateVo((item.x - minX), (item.y - minY)));
            });
        });
        this.drawBoundary();
        internalCoordinates.forEach(function (item:Object, index:int, arr:Array):void {
            var gra:Graphic = new Graphic();
            gra.x = item.x;
            gra.y = item.y;
//            trace("---------------"+gra.x+"-----------------"+gra.y+"-------------item.y："+item.y+"-------------------------------------");
            var ellipse:Ellipse = new Ellipse();
            ellipse.width = 7;
            ellipse.height = 7;
            ellipse.stroke = new SolidColorStroke(0x66CCFF, 5, 1);
            ellipse.alpha = 0.7;
            gra.addElement(ellipse);
            gra.addEventListener(MouseEvent.MOUSE_OVER, ellipse_mouseOverHandler);
            gra.addEventListener(MouseEvent.MOUSE_OUT, ellipse_mouseOverHandler);
            gra.addEventListener(MouseEvent.CLICK, gra_clickHandler);
            gcGroup.addElement(gra);
        });
    }

    /**
     *  点 over 和 out 的监听函数
     * @param event
     */
    private function ellipse_mouseOverHandler(event:MouseEvent):void {
        var g:Graphic = event.target as Graphic;
        var multiple:Number = 1;
        var xyMultiple:Number = 2;
        switch (event.type) {
            case MouseEvent.MOUSE_OVER:
                multiple = 1.5;
                xyMultiple = -2;
                break;
            case MouseEvent.MOUSE_OUT:
                multiple = 1 / 1.5;
                break;
        }
        g.alpha = g.alpha * multiple;
        g.width = g.width * multiple;
        g.height = g.height * multiple;
        g.x += xyMultiple;
        g.y += xyMultiple;
    }

    /**
     *  画边界
     */
    private function drawBoundary():void {
        var boundary:Path = new Path();
        /* this.findLeftTopCoordinate(function(x:int, y:int):void{
         boundary.x = x;
         boundary.y = y;
         });*/
        boundary.x = boundary.x + offsetX;
        boundary.y = boundary.y + offsetY;
        boundary.stroke = new SolidColorStroke(0x66CCFF, 1, 1);
        boundary.data = boundaryPath();
        this.addElement(boundary);
    }

    /**
     *  获取边界途径
     * @return
     */
    private function boundaryPath():String {
        var path:String = "M ";
        this.internalCoordinates.forEach(function (item:Object, index:int, arr:Array):void {
            path += (item.x + " " + item.y + " ");
        });
        path += "Z";
        return path;
    }

    /**
     *  确定最小的 X 和 Y 坐标
     * @param callback
     */
    private function findLeftTopCoordinate(callback:Function):void {
        this._roomReductionCoordinates.toArray().forEach(function (item:Object, index:int, arr:Array):void {
            if (index == 0) {
                minX = item.x;
                minY = item.y;
            } else {
                if (minX > item.x) {
                    minX = item.x;
                }
                if (minY > item.y) {
                    minY = item.y;
                }
            }
        });
        callback.call(null, minX, minY);
    }

    /**
     *  坐标点击
     * currentRect is null 开始画对角线
     * currentRect si not null 检测对角线落点
     * @param event
     */
    private function gra_clickHandler(event:MouseEvent):void {
        if (this.pointOffsetXInStage < 0) {
            /* Alert.show("event.stageX："+event.stageX + " event.stageY:" + event.stageY + " event.target.x:"
             + event.target.x + " event.target.y:" + event.target.y + " event.localX:" + event.localX + " event.localY:" + event.localY);*/
            var that:* = this;
            CalculationUtils.getStageCoordinateOffset(event.stageX, event.stageY,
                    event.target.x, event.target.y, event.localX, event.localY, function (offsetXInstage:Number, offsetYInstage:Number):void {
                        that.pointOffsetXInStage = offsetXInstage;
                        that.pointOffsetYInStage = offsetYInstage;
                    });
        }
//        Alert.show(event.localX + ":" +event.localY + "-" + event.target.width + ":" + event.target.height)
        if (this.currentRect == null) {
            this.currentRect = new CustomRect();
            this.currentRect.stroke = new SolidColorStroke(0x33DDFF, 3, 1);
            this.currentRect.fill = new SolidColor(0xffaa45, 0.5);
            if (event.target is Graphic) {
                var graphic:Graphic = event.target as Graphic;
                this.currentRect.x = graphic.x + (graphic.width / 2 - 2);
                this.currentRect.y = graphic.y + (graphic.height / 2 - 2);
                this.currentRect.width = 0;
                this.currentRect.height = 0;
                this.currentRect.setLetTopCoordinate(graphic.x + Constants.CUSTOM_RECT_OFFSET_XY, graphic.y + Constants.CUSTOM_RECT_OFFSET_XY);

                mouseLocationX = graphic.x;
                mouseLocationY = graphic.y;
            } else {

            }
            gcGroup.addElement(this.currentRect);
            this.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveHandler);
            this.addEventListener(MouseEvent.RIGHT_MOUSE_DOWN, rightMouseDownHandler);
        } else {
            // 点击预设的节点
            if (event.target is Graphic) {
                var endGraphic:Graphic = event.target as Graphic;
                this.currentRect.width = endGraphic.x + (endGraphic.width / 2 - 2)  - this.currentRect.x;
                this.currentRect.height = endGraphic.y + (endGraphic.width / 2 - 2) - this.currentRect.y;
                this.currentRect.setRightBottomCoordinate(endGraphic.x + Constants.CUSTOM_RECT_OFFSET_XY, endGraphic.y + Constants.CUSTOM_RECT_OFFSET_XY);
                this.removeEventListener(MouseEvent.MOUSE_MOVE, mouseMoveHandler);
                this.removeEventListener(MouseEvent.RIGHT_MOUSE_DOWN, rightMouseDownHandler);
                // 基础：需要预设点，准确坐标
                // 0. 不允许跨线画矩形，只允许在房间范围内画矩形，及画出来的矩形不能超出房间范围
                // 1.获取房间与画出的矩形的交集坐标
                // 2.然后在预览窗口显示划分的情况，然后在预览里可以合并
                // 3. 实现变形划分
                CalculationUtils.calculationPolygonIntersection(this._roomValidCoordinates,this.currentRect,this.minX,this.minY);
                // 允许开始画第二个矩形
                this.rectList.addItem(this.currentRect);
                this.currentRect = null;
            }else{ // 点击空白地

            }
        }

    }

    /**
     *  鼠标移动，寻找对角线落点
     * @param event
     */
    private function mouseMoveHandler(event:MouseEvent):void {
        /*mouseLocationX = event.stageX;
         mouseLocationY = event.stageY;*/
        if (event.target is Graphic) {
            var graphic:Graphic = event.target as Graphic;
            this.currentRect.width = graphic.x + (graphic.width / 2 - 2) - this.currentRect.x;
            this.currentRect.height = graphic.y + (graphic.width / 2 - 2) - this.currentRect.y;
            mouseLocationX = graphic.x;
            mouseLocationY = graphic.y;
        } else {
            var b:Boolean = CalculationUtils.isPointInPolygonAdapter((event.stageX - this.pointOffsetXInStage),
                    (event.stageY - this.pointOffsetYInStage), this._roomValidCoordinates, this.minX, this.minY);
            if (!b) {
                return;
            }
            this.currentRect.width = event.stageX - this.pointOffsetXInStage - this.currentRect.x;
            this.currentRect.height = event.stageY - this.pointOffsetYInStage - this.currentRect.y;
            mouseLocationX = event.stageX - this.pointOffsetXInStage;
            mouseLocationY = event.stageY - this.pointOffsetYInStage;
        }
    }

    /**
     * 取消当先 currentRect
     * @param event
     */
    private function rightMouseDownHandler(event:MouseEvent):void {
        this.removeEventListener(MouseEvent.MOUSE_MOVE, mouseMoveHandler);
        gcGroup.removeElement(this.currentRect);
        this.currentRect = null;
    }
    ]]></fx:Script>

    <!--<fx:Style source="resources/css/Styles.css"/>-->

<s:Group id="gcGroup" left="{offsetX - 3}" top="{offsetY - 3}">
    <s:layout>
        <s:BasicLayout/>
    </s:layout>
</s:Group>
    <!--<s:Panel title="预览"  width="{gcGroup.width + 100}" height="90%" right="3"/>-->
<!--<demo:EllipseDemo/>-->
</s:TitleWindow>
